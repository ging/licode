---
layout: default
title: Client API
clientapi: true
---

<!-- Subhead
================================================== -->
<header class="jumbotron subhead" id="overview">
  <div class="container">
    <h1>Client API</h1>
    <p class="lead">JavaScript library that will be used within your web applications.</p>
  </div>
</header>


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span3 bs-docs-sidebar">
        <ul class="nav nav-list bs-docs-sidenav">
          <li><a href="#overview"><i class="icon-chevron-right"></i> Overview</a></li>
          <li><a href="#stream"><i class="icon-chevron-right"></i> Stream</a></li>
          <li><a href="#room"><i class="icon-chevron-right"></i> Room</a></li>
          <li><a href="#events"><i class="icon-chevron-right"></i> Events</a></li>
          <li><a href="#examples"><i class="icon-chevron-right"></i> Examples</a></li>
          <li><a href="#erizofc"><i class="icon-chevron-right"></i> Node.js client</a></li>
        </ul>
      </div>
      <div class="span9">



        <!-- Overview
        ================================================== -->
        <section id="overview">
          <div class="page-header">
            <h1>Overview</h1>
          </div>
          <p class="lead"> You will use this API to handle connections to rooms and streams in your web applications.</p>
          <p> This API is designed to be executed in the browsers of your users, so it is provided as a JavaScript file you can reference in your web applications.</p>
          <p> Typical usage consists of: connection to the desired room, using the token retreived in the backend (explained at <a href="server-api.html">Server API</a>), management of local audio and video, client event handling, and so on.</p>
          <p> Here you can see the main classes of the library:</p>
          <table class="table table-hover table-bordered">
              <caption><strong>List of classes in Client API</strong></caption>
              <thead>
                <tr>
                  <th>Class</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><a href="#stream">Erizo.Stream</a></td>
                  <td>Provides access to local and remote video, audio and data streams in a Licode Room.</td>
                </tr>
                <tr>
                  <td><a href="#room">Erizo.Room</a></td>
                  <td>Represents a Licode Room and provides connection, local stream publication and remote stream subscription.</td>
                </tr>
                <tr>
                  <td><a href="#events">Erizo.Events</a></td>
                  <td>A set of different event types that represents a generic Event in the library.</td>
                </tr>
              </tbody>
            </table>
        </section>

        <!-- Stream
        ================================================== -->
        <section id="stream">
          <div class="page-header">
            <h1>Erizo.Stream</h1>
          </div>
          <p class="lead"> It will handle the WebRTC (audio, video and/or data) stream, identify it, and where it should be drawn.</p>
          <p>They could be local or remote. Licode internally creates remote streams through the <a href="#room">Erizo.Room</a> APIs.
          <p>It will identify each local and remote streams with <code>stream.getID()</code> and it controls where it should be drawn in the HTML page according to <code>stream.play()</code> (just in case they are video/audio streams).

          <p>You need to initialize the Stream before you can use it in the Room. Typical initializacion of Stream is:
<pre class="prettyprint linenums">
 var stream = Erizo.Stream({audio:true, video:false, data: true, attributes: {name:'myStream'}});</pre>
 <p>
          <code>audio</code>, <code>video</code> and <code>data</code> variables has to be set to true if you want to publish them in the room. While <code>attributes</code> variable can store additional information related to the stream. This information will be shared between clients in the room.</p>

          <p>If you want to use a stream to share your screen you should initialize it this way:
<pre class="prettyprint linenums">
 var stream = Erizo.Stream({screen: true, data: true, attributes: {name:'myStream'}});</pre>
 <p>
 Note that, if you use a Stream this way, the client that will share its sreen must access to your web app using a secure connection (with https protocol) and use a screensharing plugin as explained <a href="http://lynckia.com/licode/plugin.html">here</a>.</p>

          <p>You can also specify some constraints about the video size when creating a stream. In order to do this you need to include a <code>videoSize</code> parameter that is an array with the following format: <code>[minWidth, minHeight, maxWidth, maxHeight]</code>
<pre class="prettyprint linenums">
 var stream = Erizo.Stream({video: true, audio: true, videoSize: [320, 240, 640, 480]});</pre>
 <p>

 <p> Also, you can create a stream to publish an external source to the Licode session. At this point, RTSP and files are supported, depending on the Codec (only H.264 for RTSP and VP8 + (OPUS or PCMU8) for files. You can create an external stream by using the <code>url</code> variable. These streams can be then published just as if they were a local stream.</p>
 <p> For instance, to create a stream from a rtsp source:</p>
<pre class="prettyprint linenums">
 var stream = Erizo.Stream({video: true, audio: false, url:"rtsp://user:pass@the_server_url:port"});</pre>
 <p>
 <p> Or, to create a stream from a .mkv file:</p>
<pre class="prettyprint linenums">
 var stream = Erizo.Stream({video: true, audio: false, url:"file:///path_to_file/movie.mkv"});</pre>
 <p>
          <p> You can access the next variables in a stream object:</p>
          <ul>
            <li><code>stream.showing</code> to check whether the stream is locally playing our video/audio.</li>
            <li><code>stream.room</code> to know with which room it is connected.</li>
            <li><code>stream.local</code> to know if the given stream is local or remote.</li>
          </ul>

          <p>In the next table we can see the functions of this class:</p>

          <table class="table table-hover table-bordered">
              <caption><strong>List of functions in Stream</strong></caption>
              <thead>
                <tr>
                  <th>Function</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><a href="#hasAudio">hasAudio()</a></td>
                  <td>Indicates if the stream has audio activated.</td>
                </tr>
                <tr>
                  <td><a href="#hasAudio">hasVideo()</a></td>
                  <td>Indicates if the stream has video activated.</td>
                </tr>
                <tr>
                  <td><a href="#hasAudio">hasData()</a></td>
                  <td>Indicates if the stream has data activated.</td>
                </tr>
                <tr>
                  <td><a href="#initStream">init()</a></td>
                  <td>Initializes the local stream.</td>
                </tr>
                <tr>
                  <td><a href="#closeStream">close()</a></td>
                  <td>Closes the local stream.</td>
                </tr>
                <tr>
                  <td><a href="#showStream">play(elementID, options)</a></td>
                  <td>Draws the video or starts playing the audio in the HTML.</td>
                </tr>
                <tr>
                  <td><a href="#hideStream">stop()</a></td>
                  <td>Removes the video from the HTML.</td>
                </tr>
                <tr>
                  <td><a href="#muteAudio">muteAudio(isMuted, callback)</a></td>
                  <td>Mutes the audio track of a <b>remote</b> stream.</td>
                </tr>
                <tr>
                  <td><a href="#sendData">sendData(msg)</a></td>
                  <td>It sends data through the Stream to clients that are subscribed.</td>
                </tr>
                <tr>
                  <td><a href="#getAttributes">getAttributes()</a></td>
                  <td>Gets the attributes variable stored when you created the stream.</td>
                </tr>
                <tr>
                  <td><a href="#setAttributes">setAttributes()</a></td>
                  <td>It sets new attributes to the local stream that are spread to the room.</td>
                </tr>
                <tr>
                  <td><a href="#getVideoFrame">getVideoFrame()</a></td>
                  <td>It gets a Bitmap from the video.</td>
                </tr>
                <tr>
                  <td><a href="#getVideoFrameURL">getVideoFrameURL()</a></td>
                  <td>It gets the URL of a Bitmap from the video.</td>
                </tr>
                <tr>
                  <td><a href="#updateConfiguration">updateConfiguration(config, callback)</a></td>
                  <td>Updates the spec of a stream</td>
                </tr>
              </tbody>
          </table>

          <h3 id="hasAudio">Check if the stream has audio, video and/or data active</h3>
          <p>You can check if the stream has audio, video and/or data activated by these functions.
          <div class="bs-docs-example">
            The function in line 1 checks the audio while the function in line 2 checks the video and the function in line 3 checks the data.
          </div>
<pre class="prettyprint linenums">
stream.hasAudio();
stream.hasVideo();
stream.hasData();</pre>

          <h3 id="initStream">Initialize the Stream</h3>

          <p>It initializes the stream and tries to retrieve a stream from local video and audio (in case you've activated them). <p>You need to call this method before you can publish the stream in the room or play it locally.

          <div class="bs-docs-example">
          When you first create the stream, you need to initialize it (line 1). Then you need to add an event listener to know when the user has granted access to the webcam and/or microphone (line 2). You will receive an <em>access-accepted</em> or and <em>access-denied</em> event.
          </div>
<pre class="prettyprint linenums">
stream.init();
stream.addEventListener('access-accepted', function(event) {
  console.log("Access to webcam and/or microphone granted");
});
stream.addEventListener('access-denied', function(event) {
  console.log("Access to webcam and/or microphone rejected");
});
</pre>

          <h3 id="closeStream">Close a local stream</h3>

          <p>It closes a local stream.
          <p>If the stream has audio and/or video this method also stops the capture of your camera and microphone.
          <p>If the stream is published in a room this method also unpublish it.
          <p>If the stream is playing in a div this method also stops it.

          <div class="bs-docs-example">
          You can close a local stream previously initialized with this code.
          </div>
<pre class="prettyprint linenums">
stream.close();
</pre>
          <h3 id="showStream">Play a local stream in the HTML</h3>

          <p>It starts playing the video/audio at once at the given <code>elementID</code>. It automatically creates an audio/video HTML tag.

          <div class="bs-docs-example">
          You can play the video/audio only when you have already received the <em>access-accepted</em> event. And you need to pass the <code>elementID</code> as argument. You can optionally hide the volume slider with the <code>options</code> argument.
          </div>
<pre class="prettyprint linenums">
stream.play(elementID, {speaker: false});
</pre>

          <div class="bs-docs-example">
          By default video streams are automatically adapted to the div that contains them. But it sometimes implies that the video will be croped. If you don't want to crop the video you can do like this:
          </div>
<pre class="prettyprint linenums">
stream.play(elementID, {crop: false});
</pre>

          <h3 id="hideStream">Remove the local stream from the HTML</h3>

          <p>It stops playing the video/audio.

          <div class="bs-docs-example">
          You can stop to play the video/audio in the HTML with this code.
          </div>
<pre class="prettyprint linenums">
stream.stop();
</pre>
          
          <h3 id="muteAudio">Mute the audio track of a remote stream</h3>

          <p>It stops receiving audio from a remote stream. The publisher of the stream will keep sending audio information to Licode but this particular subscriber won't receive it.
          <p> <b>Note:</b> it won't work on local streams, in p2p rooms or when the stream does not have an audio track.

          <div class="bs-docs-example">
          You can mute the audio track (and stop receiving audio bytes) from the remote stream. 
          </div>
<pre class="prettyprint linenums">
stream.muteAudio(true, function (result) {
  if (result === 'error') {
    console.log("There was an error muting the steram")
  }
});
</pre>
          <div class="bs-docs-example">
          You can also unmute the audio track. 
          </div>
<pre class="prettyprint linenums">
stream.muteAudio(false, function (result) {
  if (result === 'error') {
    console.log("There was an error unmuting the steram")
  }
});
</pre>

          <h3 id="sendData">Send Data through the stream</h3>

          <p>It sends a message through this stream. All users that are already subscribed to it will received the message.

          <div class="bs-docs-example">
          The client can send any JSON serializable message through this function, and it will be received through a <code>stream-data</code> event sent from the stream. So all clients should be previously subscribed to this stream.
          </div>
<pre class="prettyprint linenums">
stream.sendData({text:'Hello', timestamp:12321312});
</pre>

        <h3 id="getAttributes">Get the attributes object</h3>

          <p>Gets the attributes object that the user stored or updated in the stream.

          <div class="bs-docs-example">
          The attributes variable is usually a JSON object.
          </div>
<pre class="prettyprint linenums">
var stream = Erizo.Stream({audio:true, video:false, data: true, attributes: {name:'myStream', type:'public'}});

var attributes = stream.getAttributes();
if(attributes.type === 'public') {
  console.log(attributes.name);
}
stream.addEventListener("stream-attributes-update", function(evt) {
  var stream = evt.stream;
  // Handle stream attribute event.
});
</pre>

      <h3 id="setAttributes">Set the attributes object</h3>

  <p>Updates attributes object in the stream. It can only be used in local streams and the changes will be propagated to the users who are subscribed to such stream.
  Other users will be notified through a special event called <em>stream-attributes-update</em>.
  <div class="bs-docs-example">
  The attributes variable is usually a JSON object.
  </div>
<pre class="prettyprint linenums">
var stream = Erizo.Stream({audio:true, video:false, data: true, attributes: {name:'myStream', type:'public'}});

var attributes = stream.setAttributes({name: 'myStreamUpdated', type: 'private'});
</pre>
          <h3 id="getVideoFrame">Get a frame from the video</h3>

          <p>It gets an image frame from the video.

          <div class="bs-docs-example">
          The client can get the bitmap raw data from the video streams. The Stream returns the Bitmap data. You can put it in a canvas element. If you want to get the image periodically you can set an interval.
          </div>
<pre class="prettyprint linenums">
var bitmap;
var canvas = document.createElement('canvas');
var context = canvas.getContext('2d');

canvas.id = "testCanvas";
document.body.appendChild(canvas);

setInterval(function() {

  bitmap = stream.getVideoFrame();

  canvas.width = bitmap.width;
  canvas.height = bitmap.height;

  context.putImageData(bitmap, 0, 0);

}, 100);
</pre>

        <h3 id="getVideoFrameURL">Get the URL of a frame from the video</h3>

          <p>It gets the URL of an image frame from the video.

        <h3 id="updateConfiguration">Update the spec of a stream</h3>

          <p>It updates the audio and video maximum bandwidth for a publisher.
          <p>It can also be used in remote streams to toggle <code>slideShowMode</code>

          <div class="bs-docs-example">
          You can update the maximun bandwidth of video and audio. These values are defined in the object passed to the function. You can also pass a callback function to get the final result.
          </div>
<pre class="prettyprint linenums">
var config = {maxVideoBW: 300, maxAudioBW: 300};

localstream.updateConfiguration(config, function(result) {
  console.log(result);
});

// We can update options also on a remote stream

remoteStream.updateConfiguration({slideShowMode:true}, function (result){
console.log(result);
});
</pre>

        </section>

        <!-- Room
        ================================================== -->
        <section id="room">
          <div class="page-header">
            <h1>Erizo.Room</h1>
          </div>
          <p class="lead">It represents a Licode Room. It will handle the connection, local stream publication and remote stream subscription.</p>
          <p> Typical Room initialization would be:
          <pre class="prettyprint linenums">
var room = Erizo.Room({token:'213h8012hwduahd-321ueiwqewq'});</pre>
          <p>It will create the room object by passing the token this users have previously received from your service. This token is has to be retreived using the <a href="server-api.html">Server API</a>, because it is a user access token. But you need to call to the connect function we will see later in order to connect to the room.

          <p> You can access some variables like:
          <ul>
            <li><code>room.localStreams</code> to retrieve the current list of local streams available in the room.</li>
            <li><code>room.remoteStreams</code> to retrieve the current list of remote streams available in the room.</li>
            <li><code>room.roomID</code> to know the identifier of this room.</li>
            <li><code>room.state</code> to access the current state of the room. States can be 0 if it is disconnected, 1 if it is connecting, and 2 if it is connected.</li>
          </ul>

          <p>In the next table we can see the functions of this class:</p>

          <table class="table table-hover table-bordered">
              <caption><strong>List of functions in Room</strong></caption>
              <thead>
                <tr>
                  <th>Function</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><a href="#connectRoom">connect()</a></td>
                  <td>It stablishes a connection to the room.</td>
                </tr>
                <tr>
                  <td><a href="#publishStream">publish(stream)</a></td>
                  <td>It publishes the <code>stream</code>.</td>
                </tr>
                <tr>
                  <td><a href="#subscribeStream">subscribe(stream)</a></td>
                  <td>It subscribes to a remote <code>stream</code>.</td>
                </tr>
                <tr>
                  <td><a href="#unsubscribeStream">unsubscribe(stream)</a></td>
                  <td>It unsubscribes from the <code>stream</code>.</td>
                </tr>
                <tr>
                  <td><a href="#unpublishStream">unpublish(stream)</a></td>
                  <td>It unpublishes the local stream.</td>
                </tr>
                <tr>
                  <td><a href="#disconnectRoom">disconnect()</a></td>
                  <td>It disconnects from the room.</td>
                </tr>
                <tr>
                  <td><a href="#recordStreamStart">startRecording(stream)</a></td>
                  <td>Starts recording the stream.</td>
                </tr>
                <tr>
                  <td><a href="#recordStreamStop">stopRecording(recordingId)</a></td>
                  <td>Stops a recording identified by its <code>recordingId</code>.</td>
                </tr>
                <tr>
                  <td><a href="#getStreamsByAttribute">getSreamsByAttribute(name, value)</a></td>
                  <td>It returns a list of the remote streams that have the attribute specified by name - value strings.</td>
                </tr>
              </tbody>
            </table>

          <h3 id="connectRoom">Open a connection to Room</h3>
          <p>It establishes a connection to the room. This function is asynchronous so we need to add an event listener to know when we are finally connected to the room. It will throw a <em>room-connected</em> event when it occurs.
          <div class="bs-docs-example">
            The <code>room</code> has to be previously created with a valid token. Then we connect to the room (line 1), and we add an event listener to wait for the connection to be established (line 2).
            <p>Please, take into account that you can't do anything else with the room until you have received this event!!.
          </div>
<pre class="prettyprint linenums">
room.connect();
room.addEventListener("room-connected", function(event) {
  console.log("Connected!");
});</pre>

          <h3 id="publishStream">Publish the local stream</h3>
          <p>It publishes the local stream given by an argument called <code>stream</code>.
          <p>Your client should be connected to the <code>room</code> and the stream should be first initialized.
          <p>When you call this function it starts to send video or audio to your Licode Room. Once the stream is ready all clients in the room will receive a <em>stream-added</em> event with the information about your stream and they could subscribe to it.</p>
          <div class="bs-docs-example">
            For publishing you first need to create and initialize a stream and connect to the room. Then you give the stream to the room in order to publish the streams it handles (line 1).
            <p>It throws a <em>stream-added</em> <a href="#events">Event</a> when the stream is finally published in the room, beacuse it will be added. So you have to add and event listener to handle it (line 2), and then check if the stream is the one you have just published (line 3).
          </div>
            <pre class="prettyprint linenums">
room.publish(localStream);
room.addEventListener("stream-added", function(event) {
  if (localStream.getID() === event.stream.getID()) {
    console.log("Published!!!");
  }
});</pre>
            <p><code>room.publish</code> also allows to set a bandwidth limit for the localStream. We do this by passing the <code>maxVideoBW</code> variable as an option. The BW is expressed in Kbps. Keep in mind that the field <code>config.erizoController.defaultVideoBW</code>
            in the server configuration has higher priority than this one.</p>

            <pre class="prettyprint linenums">
room.publish(localStream, {maxVideoBW:300});
</pre>


            <p>In <code>room.publish</code> you can include a callback with two parameters, <code>id</code> and <code>error</code>. If the stream has been published, <code>id</code> contains the id of that stream. On the other hand, if there has been any kind of error, <code>id</code> is <em>undefined</em> and the error is described in <code>error</code>.</p>
            <div class="bs-docs-example">
              Using the callback to catch possible problems
            </div>
            <pre class="prettyprint linenums">
room.publish(localStream, {maxVideoBW:300}, function(id, error){
  if (id === undefined){
    console.log("Error publishing stream", error);
  } else {
    console.log("Published stream", id);
  }
});            </pre>
 

          <h3 id="subscribeStream">Subscribe to a remote stream</h3>
          <p>It subscribes to a remote stream in the room.
          <p>For subscribing to a stream you first need to connect to the room and know which streams are available in the room. So as we have already seen we first need to add an event listener to receive <em>stream-added</em> events.
          <p>In this case you will need an object of the <a href="#stream">Stream</a> class, that we receive with that event.
          <div class="bs-docs-example">
            You first need to connect to a room, and receive an event with the stream you want to subscribe.
            <p> NOTE: You can subscribe to the stream you are publishing, but you will receive it with delay. We recommend you to use the <a href="#stream">Stream</a> API to play directly your local streams.
          </div>
<pre class="prettyprint linenums">
room.addEventListener("stream-subscribed", function(streamEvt) {
  console.log("Stream subscribed");
});
room.subscribe(stream);</pre>

          <p>You can choose which components (audio/video) of the stream you want to subscribe to using the second parameter of <code>subscribe</code> method.
          <div class="bs-docs-example">
            Here we are going to subscribe to the audio but not to the video.
          </div>
<pre class="prettyprint linenums">
room.addEventListener("stream-subscribed", function(streamEvt) {
  console.log("Stream subscribed");
});
room.subscribe(stream, {audio: true, video: false});</pre>

      <p>In <code>room.subscribe</code> you can include a callback with two parameters, <code>result</code> and <code>error</code>. If the stream has been subscribed, <code>result</code> is <em>true</em>. On the other hand, if there has been any kind of error, <code>result</code> is <em>undefined</em> and the error is described in <code>error</code>.</p>
            <div class="bs-docs-example">
              Using the callback to catch possible problems
            </div>
            <pre class="prettyprint linenums">
room.subscribe(stream, {audio: true, video: false}, function(result, error){
  if (result === undefined){
    console.log("Error subscribing to stream", error);
  } else {
    console.log("Stream subscribed!");
  }
});</pre>

            <p>When subscribing you can also configure the receiver to receive a lower bitrate Video stream from the publisher. We call this feature <em>slideShowMode</em>. By enabling it, this subscriber will receive one frame every two seconds from the publisher and won't affect the quality of other subscribers.
            <pre class="prettyprint linenums">
room.subscribe(stream, {audio: true, video: true, slideShowMode:true}, function(result, error){
  if (result === undefined){
    console.log("Error subscribing to stream", error);
  } else {
    console.log("Stream subscribed!");
  }
});</pre>
            <p><code>SlideShowMode</code> can also be toggled on or off using <code>stream.updateConfiguration</code>. Keep in mind this will only work on remote streams (subscriptions).

          <h3 id="unsubscribeStream">Unsubscribe from a remote stream</h3>
          <p>You can unsubscribe from a stream you are currently subscribed.
          <p>Here apply the same requirements seen in the subscription.
          <div class="bs-docs-example">
            You first need to be subscribed to the stream. When you unsubscribe from a stream the HTML element will be empty.
          </div>
<pre class="prettyprint linenums">
room.unsubscribe(stream);</pre>

      <p>In <code>room.unsubscribe</code> you can include a callback with two parameters, <code>result</code> and <code>error</code>. If the stream has been unsubscribed, <code>result</code> is <em>true</em>. On the other hand, if there has been any kind of error, <code>result</code> is <em>undefined</em> and the error is described in <code>error</code>.</p>
            <div class="bs-docs-example">
              Using the callback to catch possible problems
            </div>
            <pre class="prettyprint linenums">
room.unsubscribe(stream, function(result, error){
  if (result === undefined){
    console.log("Error unsubscribing", error);
  } else {
    console.log("Stream unsubscribed!");
  }
});</pre>

          <h3 id="unpublishStream">Unpublish a local stream</h3>
          <p>You can unpublish your stream given in <code>stream</code> when your are connected to a room and you are currently publishing it.
          <p>Here apply the same requirements seen in the publish function.
          <p>The room will throw a <em>stream-removed</em> event to all the users when your streams are not published.
          <div class="bs-docs-example">
            You first need to be publishing the local stream. Then you can unpublish your streams at any time (line 1). You can be sure your streams are not published when you receive a <em>stream-removed</em> event (lines 2-3).
          </div>
<pre class="prettyprint linenums">
room.unpublish(localStream);
room.addEventListener("stream-removed", function(event) {
  if (localStream.getID() === event.stream.getID()) {
    console.log("Unpublished!!!");
  }
});</pre>
      <p>In <code>room.unpublish</code> you can include a callback with two parameters, <code>result</code> and <code>error</code>. If the stream has been unpublished, <code>result</code> is <em>true</em>. On the other hand, if there has been any kind of error, <code>result</code> is <em>undefined</em> and the error is described in <code>error</code>.</p>
            <div class="bs-docs-example">
              Using the callback to catch possible problems
            </div>
            <pre class="prettyprint linenums">
room.unpublish(localStream, function(result, error){
  if (result === undefined){
    console.log("Error unpublishing", error);
  } else {
    console.log("Stream unpublished!");
  }
});</pre>

          <h3 id="disconnectRoom">Disconnect from Room</h3>
          <p>You can disconnect from the room when you want.
          <p>The room will throw a <em>room-disconnected</em> event.
          <div class="bs-docs-example">
            You can disconnect from the room whenever you are previously connected.
          </div>
<pre class="prettyprint linenums">
room.disconnect();</pre>

          <h3 id="quality">Managing Quality Adaptation</h3>
          <p>By default, Licode will try to adapt the video quality of each publisher to the <em>worst</em> subscriber, that way, we ensure that all participants can partake in the conference. However, that means that video quality can be degraded for all the participants in a room if just one of them does not have enough bandwidth available.
          <p>To solve this, Licode gives you a flexible way to configure the behaviour of the adaptation <em>per publisher</em>. You specify a <code>minVideoBW</code> when you publish a stream. This will set the minimum video bitrate, you can use this when you want to control the minimum video quality for a given stream. On the subscriber, an estimate of the available bandwidth is calculated for a particular stream. Licode will react to a subscriber that is under the <code>minVideoBW</code> set by the publisher, based on the specified <a href="#schemes">adaptation scheme</a>. If no <code>scheme</code> is specified, Licode will only notify subscribers via a <code>streamEvent</code>.

                     <pre class="prettyprint linenums">
room.publish(localStream, {maxVideoBW:2000, minVideoBW: 1000});</pre>
         <h4 id="schemes">Schemes</h4>
         <p>An adaptation scheme is a behaviour patter that Licode will use on the subscribers that report having less available bandwidth than what was configured via <code>minVideoBW</code>.
         <p>Currently Licode implements three different adaptations schemes, one built on top of the other.
         <ul>
           <li><code>notify</code>: Licode will only notify periodically subscribers that are below<code>minVideoBW</code>. The possible messages, included in <code>streamEvent.msg</code> are:
             <ul>
               <li><em>insufficient</em>: Indicates the subscriber is not reporting enough bandwidth </li>
             </ul></li>
           <li><code>notify-break</code>: Licode will notify subscribers, stop adapting the publisher to problematic subscribers and relegate them to audio-only mode. The possible messages, included in <code>streamEvent.msg</code> are:
             <ul>
               <li><em>insufficient</em>: Indicates the subscriber is not reporting enough bandwidth </li>
               <li><em>audio-only</em>: Licode will now send only audio to this subscriber and the publisher will not try to adapt Video quality. </li>
             </ul></li>
           <li><code>notify-break-recover</code>: Same as notify-break but Licode will periodically try to recover the subscriber's video.The possible messages, included in <code>streamEvent.msg</code> are:
             <ul>
               <li><em>insufficient</em>: Indicates the subscriber is not reporting enough bandwidth, Licode will stop sending Video to this subscriber and the publisher won't try to adapt. </li>
               <li><em>recovered</em>: This stream has successfully recovered, reports more that minVideoBW and Licode will treat it as a stream with no bandwidth problems</li>
               <li><em>audio-only</em>: Licode will stop trying to recover and send only audio to this subscriber and the publisher will not try to adapt Video quality. </li>
             </ul></li>
         </ul>
         <p>You will have to set your desired scheme per publisher:
                     <pre class="prettyprint linenums">
room.publish(localStream, {maxVideoBW:2000, minVideoBW: 1000 scheme:"notify-break"});</pre>
         
                     <p>The default scheme is <code>notify</code>.

                     <p>Licode uses <a href=#streamEvent><code>streamEvents</code></a> to notify clients, so you will need to listen to the following events to properly take advantage of the schemes in your application. These events are:

         <ul>
           <li><code>notify</code>: Licode will only notify periodically subscribers that are below<code>minVideoBW</code>.</li>
           <li><code>notify-break</code>: Licode will notify subscribers, stop adapting the publisher to problematic subscribers and relegate them to audio-only mode.</li>
           <li><code>notify-break-recover</code>: Same as notify-break but Licode will periodically try to recover the subscriber's video.</li>
         </ul>

         <p> Keep in mind you can use this in combination with <code>SlideShowMode</code> allowing for a wide variety of configurations.


<h3 id="recordStreamStart">Start Recording</h3>
          <p>Start the recording of a stream in the server in the path specified in licode_config.js
          <p>The recording will stored in a .mkv file using VP8 codec for video and PCMU or OPUS for audio, depending on the server configuration. This file can be played directly or streamed into a Licode room.
          <p>Licode will keep recording until stopRecording is called or the stream is removed from the room.
          <div class="bs-docs-example">
            Start the recording of the local stream.
          </div>
          <pre class="prettyprint linenums">
room.startRecording(localStream, function(recordingId, error) {
  if (recordingId === undefined){
    console.log("Error", error);
  } else {
    console.log("Recording started, the id of the recording is ", recordingId);
  }
});          </pre>

          <h3 id="recordStreamStop">Stop Recording</h3>
          <p>Stop the recording of a stream. You must provide the identificator of the recording: <code>recordingId</code>.
          <div class="bs-docs-example">
            Stop the recording.
          </div>
          <pre class="prettyprint linenums">
room.stopRecording(recordingId, function(result, error){
  if (result === undefined){
    console.log("Error", error);
  } else {
    console.log("Stopped recording!");
  }
});</pre>

          <h3 id="playRecording">Playing recorded streams</h3>
          <p>There are two ways of playing a recorded stream. Both of them involve the creation of an external stream. You can either set the <code>url</code> variable to the path of the recorded file or use the <code>recordingId</code> as a variable.
          <div class="bs-docs-example">
            Play a recording from full path (url) or by using its <code>recordingId</code>.
          </div>
         <pre class="prettyprint linenums">
var stream = Erizo.Stream({video: true, audio: false, url:"file:///path_to_file/previousRecording.mkv"});
room.publish(stream);
var stream2 = Erizo.Stream({audio:true, video:true, recording: 'asda2131231'});
room.publish(stream2);</pre>

          <h3 id="getStreamsByAttribute">Get Streams by attribute</h3>
          <p>You can search remote streams by attribute. A remote stream is a room stream you have previously subscribed to.
          <div class="bs-docs-example">
            If you want to get the streams of type 'public':
          </div>
<pre class="prettyprint linenums">
var streams = room.getStreamsByAttribute('type', 'public');
//streams is an array that contains the stream objects.
</pre>

          <h3>Event Handling</h3>
          <p>Room inherits EventDispatcher (see <a href="#events">events</a> for further information), for handling RoomEvents and StreamEvents. For example:</p>
          <ul>
            <li>Event 'room-connected' points out that the user has been successfully connected to the room.</li>
            <li>Event 'room-error' indicates that there has been an error and it hasn't been possible to connect to the room.</li>
            <li>Event 'room-disconnected' shows that the user has been already disconnected.</li>
            <li>Event 'stream-added' indicates that there is a new stream available in the room.</li>
            <li>Event 'stream-removed' shows that a previous available stream has been removed from the room.</li>
          </ul>
          <p>The client could receive any event when it is connected.
          <div class="bs-docs-example">
            Despite we have shown examples of event listeners during the documentation, we strongly recommend to add event listeners before you do any action in the room. The previous examples only illustrated the  behaviour of Room's functions.
          </div>
<pre class="prettyprint linenums">
var room = Room({token:"..."});
room.addEventListener("room-connected", function(evt){...});
room.addEventListener("room-error", function(evt){...});
room.addEventListener("room-disconnected", function(evt){...});
room.addEventListener("stream-added", function(evt){...});
room.addEventListener("stream-removed", function(evt){...});
room.connect();</pre>


        </section>

        <!-- Events
        ================================================== -->
        <section id="events">
          <div class="page-header">
            <h1>Erizo.Events</h1>
          </div>
          <p class="lead">Licode provides a set of event classes to handle changes during client connection.</p>
          <p><a href="#room">Room</a> and <a href="#stream">Stream</a> classes throw different Licode events (they are <em>EventDispatchers</em>) and it's always a good idea to listen to them. Here we will explain the different kinds of events in Licode. In the next table you can see a brief description.</p>
          <table class="table table-hover table-bordered">
              <caption><strong>List of Event classes</strong></caption>
              <thead>
                <tr>
                  <th>Class</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><a href="#LicodeEvent">licode Event</a></td>
                  <td>It represents a generic Event in the library, which is inherited by the others.</td>
                </tr>
                <tr>
                  <td><a href="#roomEvent">Room Event</a></td>
                  <td>It represents an events related to Room connection.</td>
                </tr>
                <tr>
                  <td><a href="#streamEvent">Stream Event</a></td>
                  <td>It represents an event related to streams within a room.</td>
                </tr>
              </tbody>
            </table>


          <h3 id="licodeEvent">Licode Event</h3>
          <p> It handles the type of event, that is important when adding event listeners to EventDispatchers and dispatching new events.
          <div class="bs-docs-example">
            A LicodeEvent can be initialized like this, but it is usually created by Client API.
          </div>
<pre class="prettyprint linenums">
var event = Erizo.LicodeEvent({type: "room-connected"});</pre>

          <h3 id="roomEvent">Room Event</h3>
          <p> It represents connect and disconnect events.</p>
          <p> You can access the list of streams connected to the room by accessing <code>roomEvent.streams</code>.
          <p> These are the type of Room events thrown:</p>
          <ul>
            <li><em>room-connected</em>: points out that the user has been successfully connected to the room. This message also provides the list of streams that are currently published in the room.</li>
            <li><em>room-error</em>: indicates that it hasn't been possible a succesufully connection to the room.</li>
            <li><em>room-disconnected</em>: shows that the user has been already disconnected.</li>
          </ul>
          <p> They are all dispatched by Room objects</p>
          <div class="bs-docs-example">
            A RoomEvent can be initialized like this, but it is usually created by Room objects.
          </div>
<pre class="prettyprint linenums">
var roomEvent = Erizo.RoomEvent({type:"room-connected", streams:[stream1, stream2]});</pre>

          <div class="bs-docs-example">
            They all are dispatched by Room objects, so you need to add event listeners to them.
          </div>
<pre class="prettyprint linenums">
room.addEventListener("room-connected", function(evt){...});</pre>

          <h3 id="streamEvent">Stream Event</h3>
          <p> It represents an event related to a stream. </p>
          <p> You can access the related stream by <code>streamEvent.stream</code>.</p>
          <p> Some of them have a more detailed message in <code>streamEvent.msg</code>.</p>
          <p> There are the different types of Stream events:</p>
          <ul>
            <li><em>access-accepted</em>: indicates that the user has accepted to share his camera and microphone.</li>
            <li><em>access-denied</em>: indicates that the user has denied to share his camera and microphone.</li>
            <li><em>stream-added</em>: indicates that there is a new stream available in the room.</li>
            <li><em>stream-removed</em>: shows that a previous available stream has been removed from the room.</li>
            <li><em>stream-data</em>: thrown by the stream it indicates new data received in the stream.</li>
            <li><em>stream-attributes-update</em>: notifies when the owner of the given stream updates its attributes</li>
            <li><em>bandwidth-alert</em>: thrown when a subscriber stream is reporting less than the <code>minVideoBW</code> specified in the publisher. The event has three parts:
              <ul>
                <li><code>streamEvent.stream</code> is the problematic subscribe stream.</li>
                <li><code>streamEvent.bandwidth</code> is the available bandwidth reported by that stream.</li>
                <li><code>streamEvent.msg</code> the <em>status</em> of that stream, depends on the adaptation <a href="#quality">scheme</a>. </li>
              </ul>
            </li>
            <li><em>stream-failed</em>: A stream has failed, either in the connection establishment or during the communication.</li>

          </ul>
          <p> They all are dispatched by Room objects.</p>
          <p>
          <div class="bs-docs-example">
            A StreamEvent can be initialized like this, but it is usually created by Client API.
          </div>
<pre class="prettyprint linenums">
var streamEvent = Erizo.StreamEvent({type:"stream-added", stream:stream1});</pre>

          <div class="bs-docs-example">
            <code>stream-added</code>, <code>stream-removed</code> and <code>stream-failed</code> are dispatched by Room objects, so you need to add event listeners to them.
          </div>
<pre class="prettyprint linenums">
room.addEventListener("stream-removed", function(evt){...});</pre>

          <div class="bs-docs-example">
            <code>access-accepted</code>, <code>access-denied</code>, <code>stream-data</code>, <code>stream-attributes-update</code> and <code>bandwidth-alert</code> are dispatched by Stream objects, so you need to add event listeners to them.
          </div>
<pre class="prettyprint linenums">
stream.addEventListener("access-accepted", function(evt){...});

stream.addEventListener("stream-data", function(evt){
  console.log('Received data ', evt.msg, 'from stream ', evt.stream.getAttributes().name);
});

room.addEventListener("stream-attributes-update", function(evt){...});
</pre>



        </section>

        <!-- Examples
        ================================================== -->
        <section id="examples">
          <div class="page-header">
            <h1>Examples</h1>
          </div>
          <p class="lead">Here we show some examples and code snippets for typical use cases in this API.</p>

          <p> In this section we will see a set of examples to use almost every part of this API.</p>

          <div class="bs-docs-example">
          <h3 id="getWebcamEx">Basic Videoconference</h3>
            <p> In this example we will make a basic videoconference application. Every client than connects to the application will publish his video and audio and will subscribe to all the videos and audios of the other clients. This example uses an unique room.</p>
          </div>
<pre class="prettyprint linenums">
&lthtml&gt
  &lthead&gt
    &lttitle>Licode Basic Example&lt/title&gt
    &ltscript type="text/javascript" src="erizo.js">&lt/script&gt
    &ltscript type="text/javascript"&gt

      window.onload = function () {

          var localStream = Erizo.Stream({audio: true, video: true, data: true});
          var room = Erizo.Room({token: "af54/=gopknosdvmgiufhgadf=="});

          localStream.addEventListener("access-accepted", function () {

              var subscribeToStreams = function (streams) {
                  for (var index in streams) {
                    var stream = streams[index];
                    if (localStream.getID() !== stream.getID()) {
                        room.subscribe(stream);
                    }
                  }
              };

              room.addEventListener("room-connected", function (roomEvent) {

                  room.publish(localStream);
                  subscribeToStreams(roomEvent.streams);
              });

              room.addEventListener("stream-subscribed", function(streamEvent) {
                  var stream = streamEvent.stream;
                  var div = document.createElement('div');
                  div.setAttribute("style", "width: 320px; height: 240px;");
                  div.setAttribute("id", "test" + stream.getID());

                  document.body.appendChild(div);
                  stream.play("test" + stream.getID());
              });

              room.addEventListener("stream-added", function (streamEvent) {
                  var streams = [];
                  streams.push(streamEvent.stream);
                  subscribeToStreams(streams);
              });

              room.addEventListener("stream-removed", function (streamEvent) {
                  // Remove stream from DOM
                  var stream = streamEvent.stream;
                  if (stream.elementID !== undefined) {
                      var element = document.getElementById(stream.elementID);
                      document.body.removeChild(element);
                  }
              });

              room.connect();
              localStream.play("myVideo");
          });
          localStream.init();
      };
    &lt/script&gt
  &lt/head&gt

  &ltbody&gt
    &ltdiv id="myVideo" style="width:320px; height: 240px;"&gt
    &lt/div&gt
  &lt/body&gt
&lt/html&gt
</pre>

        </section>

        <!-- Erizofc
        ================================================== -->
        <section id="erizofc">
          <div class="page-header">
            <h1>Node.js client</h1>
          </div>
          <p class="lead">Running erizo clients in your node.js applications.</p>
          <p>You can also run erizo clients in your node.js applications with the same API explained here. You can connect to rooms, publish and subscribe to streams and manage events. You need only to import the node module <b>erizofc.js</b></p>
          <pre class="prettyprint linenums">
var Erizo = require('.erizofc');</pre>
          <p>And now you can use the API like explained for the browser case, calling <b>Erizo.Room</b>, <b>Erizo.Stream</b> and <b>Erizo.Events</b>. Note that you can not publish/subscribe streams with video and/or audio. We are working on this feature in order to develop another way of distribute video/audio streams.</p>
        </section>

        <!-- Next
        ================================================== -->
        <section id="what-next">
          <div class="page-header">
            <h1>What next?</h1>
          </div>
          <p class="lead">Head to the Server API for information, examples, and code snippets of the additional API to manage rooms, and give access to users, or start testing this API.</p>
          <a class="btn btn-large btn-primary" href="./server-api.html">Visit the Server API</a>
          <a class="btn btn-large" href="http://chotis2.dit.upm.es" style="margin-left: 5px;">Try it!</a>
        </section>

      </div>
    </div>

  </div>
